package $packageName;

#define PUSH 0
#define POP 1

void sort@l@s(int@s[l] toSort, int1 isAscending) = native sortLib.sort;
void sort@r@s(int@s[r] toSort, int1 isAscending) = native sortLib.sort;

void sortWithPayload@l@s@t(int@s[l] toSort, int@t[l] tuples, int1 isAscending) = native sortLib.sortWithPayload;
void sortWithPayload@r@s@t(int@s[r] toSort, int@t[r] tuples, int1 isAscending) = native sortLib.sortWithPayload;

phantom StackNode@m<T> NonRecursiveORAM@m<T>.readAndRemove(int@m id, rnd@m pos) = native conditionalReadAndRemove;
phantom void NonRecursiveORAM@m<T>.add(int@m id, int@m pos, StackNode@m<T> node) = native conditionalPutBack;

rnd@m RND(intp_32 m) = native intLib.randBools;

typedef char = int8;
typedef intp_ = public int;
typedef NonRecursiveORAM@m<T> = native CircuitOram(m, sizeof(T));

struct StackNode@m<T> {
   rnd@m next;
   T data;
};

struct Stack@m<T> {
   rnd@m root;
   int@m size;
   NonRecursiveORAM@(1 << m)< StackNode@m<T> > oram;
};

phantom void Stack@m<T>.push(T operand) {
      StackNode@m<T> node = 
         StackNode@m{T} ( next = this.root,
               data = operand);
      this.root = RND(m);
      this.size  = this.size + 1;
      this.oram.add(this.size, this.root, node);
}

phantom T Stack@m<T>.pop() {
   T ret;
   rnd@m next;
   StackNode@m<T> r = this.oram.readAndRemove(this.size, this.root);
   ret, this.root = r.(data, next);
   this.size = this.size - 1;
   return ret;
}

T Stack@m<T>.op(int operand, T value) {
  T ret;
  if (operand == PUSH) {
     this.push(value);
  } else {
     ret = this.pop();
  }
  return ret;
}

secure int1 applyFilter(secure int$lSize lTuple, secure int$rSize rTuple) {
	secure int1 ret = 0;
	$applyFilter
	
	return ret;
}

int$dSize[l*r] run@l@r(int$lSize[l] lhs, int$rSize[r] rhs) {
	     	
	secure int lTupleCount, rTupleCount;
	getArrElements(lhs, lTupleCount);
	getArrElements(rhs, rTupleCount);
		    
	secure int$dSize[secure l*r] dst;
	int dstIdx = 0;

	secure int$lSize srcTuple = 0;
	secure int$rSize t2 = 0;
	secure int1 filter = 0;

	bfor(l) (int i = 0; i < lTupleCount; i = i + 1) {
		srcTuple = lhs[i];
		
		bfor (l*r) (int j = 0; j < rTupleCount; j = j + 1) {
			t2 = rhs[j];
			filter = applyFilter(srcTuple, t2);

			if(filter == 1) {
				int$dSize dstTuple;
				$writeDst
				dst[dstIdx] = dstTuple;
				dstIdx = dstIdx + 1;
			}
		}
	}

	setArrElements(dst, dstIdx);

	return dst;

}


