Data * $functionName(Data *data) {
	// sort step needs to always put dummies last and then sort by payload
	$sortInput
	
	

	int tupleLen = data->tuples[0].size();
	int dummyIdx = tupleLen - 1;
	int payloadBits = tupleLen - 1;
	cout << " Running $functionName with " << data->publicSize << " inputs, tupleLen=" << tupleLen << endl;


    Integer lastPayload = Integer(payloadBits, data->tuples[0].bits);
    Integer payload;
    int cursor = 0;



    while ( cursor < data->publicSize - 1) {


        cursor++;
        Bit isDummy = data->tuples[cursor][dummyIdx]; // easier to perform logic checks
	
        payload =  Integer(payloadBits, data->tuples[cursor].bits);
	  
 
         // if it is real and != to predecessor
	    Bit condition = (!isDummy) & (payload != lastPayload); // set to dummy if it equals its predecessor
	    std::cout << "Comparison " << payload.reveal<int32_t>(PUBLIC) << " vs " << lastPayload.reveal<int32_t>(PUBLIC) << " dummy tag: " << (!isDummy).reveal(PUBLIC) << " setting dummy? " << condition.reveal(PUBLIC) << std::endl;
	     
        data->tuples[cursor][dummyIdx] = If(condition, Bit(false, PUBLIC), Bit(true, PUBLIC)); 
		
        lastPayload = payload;
    }




    return data;
}

