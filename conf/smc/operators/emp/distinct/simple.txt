Data * $functionName(Data *data) {
	// TODO: presort this to put dummies last
	$sortInput
	
	
	cout << " Running $functionName with " << data->publicSize << " inputs." << endl;
	int tupleLen = data->tuples[0].size() * sizeof(Bit);
	int dummyIdx = data->tuples[0].size() - 1;
	int tupleBits = data->tuples[0].size() - 1;

	Data result;

    Integer lastTuple = data->tuples[0].resize(tupleBits, 0); // compare tuple value sans dummyTag
    int cursor = 0;



    while ( cursor < data->publicSize - 1) {


        cursor++;
        Bit isDummy = data->tuples[cursor][dummyIdx]; // easier to perform logic checks
	    Integer payload = data->tuples[cursor].resize(tupleBits, 0);
	  
       // std::cout << "Comparison " << (current==lastOne).reveal(PUBLIC) << std::endl;
	     
	     Bit condition = !isDummy; // would terminate early if we encounter a dummy
	     condition = condition & !payload.equal(lastTuple); // set to dummy if it equals its predecessor
	     
	    data->tuples[cursor][dummyIdx] = If(condition, Bit(false, PUBLIC), Bit(true, PUBLIC)); 
		
        lastTuple = payload;
    }




    return data;
}

