Data * $functionName(Data *data) {

	// sort by 1) dummy tag and 2) group-by column(s)
	// such that all dummies are at the end 
	// and tuples in the same group-by bin are adjacent
	$sortInput

    // Initialize new Data object for end results
    Data *result = new Data;
    result->tuples = new Integer[data->publicSize];



    // set index 0 init
    Bit init = If(data->dummyTags[0], Bit(), Bit(true,PUBLIC));
    Integer value = If(init, Integer(64,1,PUBLIC), Integer(64,1,PUBLIC));

    Integer lastOne = data->data[0];
    int cursor = 0;

    Integer tuple;
    $initAgg


	 // holds all associated aggregate values
    std::vector<Integer> myVect;
    myVect.reserve(data->publicSize);
    myVect.push_back(value);

    while ( cursor < data->publicSize - 1) {

        cursor++;
        tuple = data->data[cursor];
        Bit dummyOut = data->dummyTags[cursor];
        Bit dummyTest = !(data->dummyTags[cursor]); // easier to perform logic checks


        // if init and equal, set dummyOut to True for reverse logic
        dummyOut = If((init & (tuple==lastOne)), Bit(true,PUBLIC), dummyOut);

        // reset init so that it will be false if we have not seen
        // a real of the current Integer value
        init = If((tuple==lastOne), (init | dummyTest), dummyTest);

        // create new integer to add to the new data type
        Integer *output = new Integer($dSize, 0, PUBLIC);

        // Compute all aggregates
        $processAgg

        // extractGroupBy in SecureAggregate
        $writeGroupBy

        // extract each aggregate to output
        $writeAggregate 

	    myVect.push_back(*output);


        // if we are initialized, move lastOne to current. Else do not move lastOne
        lastOne = If(init, tuple, lastOne);


        // insert current output
        result->data[cursor] = *output;


        // replace current dummy
        result->dummyTags[cursor] = dummyOut;



    }

   // reset variables
   Bit prevDummy = data->dummyTags[0];
   cursor = 1;
   Bit real = Bit();

   // swap first and last dummy positions and reset values
   // TODO: apply only to result, logic needs to be updated

   while ( cursor < data->publicSize) {
        Bit prevDummy = data->dummyTags[cursor-1];
        Bit currDummy = data->dummyTags[cursor];
        Integer prevValue = data->data[cursor-1];
        Integer currValue = data->data[cursor];
        Bit same = If(prevValue==currValue, !Bit(), Bit());

        Bit prevtemp = If(prevDummy==real & currDummy!=real & same, !Bit(),prevDummy);
        Bit currtemp = If(prevDummy==real & currDummy!=real & same, Bit(), currDummy);

        // replace current dummy
        data->dummyTags[cursor-1] = prevtemp;
        data->dummyTags[cursor] = currtemp;

        // replace aggregate value
        data->data[cursor-1] = myVect[cursor-1];

        cursor++;
    }

    data->data[data->publicSize-1] = myVect[data->publicSize-1];

    // debugging statements to see new values
    for(int i = 0; i < data->publicSize; i++){
            long value = result->data[i].reveal<int32_t>(PUBLIC);
            cout << "Value i: " << value << endl;
            std::cout << data->dummyTags[i].reveal(PUBLIC) << std::endl;
    }

    return data;
}
