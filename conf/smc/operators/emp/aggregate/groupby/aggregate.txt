Data * $functionName(Data *data) {

	$sortInput

    // Initialize new Data object for end results
    Data *result = new Data;
    result->data = new Integer[data->publicSize];
    result->publicSize = data->publicSize;
    result->dummyTags = new Bit[data->publicSize];

	std::cout << "groupby Aggregate being used" << std::endl;

    // set index 0 init
    Bit init = If(data->dummyTags[0],Bit(),Bit(true,PUBLIC));
    Integer value = If(init,Integer(64,1,PUBLIC),Integer(64,1,PUBLIC));

    Integer lastOne = data->data[0];
    int cursor = 0;

    $initAgg



    while ( cursor < data->publicSize - 1) {

        cursor++;
        Integer current = data->data[cursor];
        Bit dummyOut = data->dummyTags[cursor];
        Bit dummyTest = !(data->dummyTags[cursor]); // easier to perform logic checks
        Bit initPrev = init;


        // if init and equal, set dummyOut to True for reverse logic
        dummyOut = If((init & (current==lastOne)),Bit(true,PUBLIC),dummyOut);

        // reset init so that it will be false if we have not seen
        // a real of the current Integer value
        Bit temp = If((current==lastOne),(init | dummyTest),dummyTest);
        init = temp;

        // create new integer to add to the new data type
        Integer *output = new Integer($dSize, 0, PUBLIC);

        // Compute all aggregates
        $processAgg

        // extractGroupBy in SecureAggregate
        $writeGroupBy

        // extract each aggregate to output
        $writeAggregate //


        // if we are initialized, move lastOne to current. Else do not move lastOne
        lastOne = If(init,current,lastOne);


        // insert current output
        result->data[cursor] = output;


        // replace current dummy
        result->dummyTags[cursor] = dummyOut;



    }

   // reset variables
   Bit prevDummy = data->dummyTags[0];
   cursor = 1;
   Bit real = Bit();

   // swap first and last dummy positions and reset values
   // TODO: apply only to result, logic needs to be updated

   while ( cursor < data->publicSize) {
        Bit prevDummy = data->dummyTags[cursor-1];
        Bit currDummy = data->dummyTags[cursor];
        Integer prevValue = data->data[cursor-1];
        Integer currValue = data->data[cursor];
        Bit same = If(prevValue==currValue,!Bit(),Bit());

        Bit prevtemp = If(prevDummy==real & currDummy!=real & same, !Bit(),prevDummy);
        Bit currtemp = If(prevDummy==real & currDummy!=real & same, Bit(), currDummy);

        // replace current dummy
        data->dummyTags[cursor-1] = prevtemp;
        data->dummyTags[cursor] = currtemp;

        // replace aggregate value
        data->data[cursor-1] = myVect[cursor-1];

        cursor++;
    }

    data->data[data->publicSize-1] = myVect[data->publicSize-1];

    // debugging statements to see new values
    for(int i = 0; i < data->publicSize; i++){
            long value = data->data[i].reveal<int32_t>(PUBLIC);
            cout << "Value i: " << value << endl;
            std::cout << data->dummyTags[i].reveal(PUBLIC) << std::endl;
    }

    return data;
}