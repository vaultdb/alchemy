

// expects as arguments party (1 = alice, 2 = bob) plus the port it will run the protocols over

public:
void setGeneratorHost(string host) {
     aliceHost = host;
}


// placeholder for maintaining a map of inputs from JDBC
void addInput(const std::string& opName, const std::string& bitString, const std::string& dummyTags) {

     inputs[opName] = bitString;
     dummyTagsMap[opName] = dummyTags;

     }


const std::string& getOutput() {
      return output;
}

void run(int party, int port) {
	
	std::cout << "starting run in emp! party=" << party << " port=" << port <<  std::endl;
	NetIO * io = new NetIO((party==ALICE ? nullptr : aliceHost.c_str()), port);
    
    setup_semi_honest(io, party);
    
    $functions
    
    Data * results = $rootOutput;

    int tupleWidth = results->data[0].size();
    int dummyCount = results->publicSize;

    // Debugging assistance
    std::cout << "The number of dummies after all operations is " << dummyCount << std::endl;
    std::cout << "Output tuple width is " << tupleWidth << std::endl;


    long outputSize = results->publicSize * tupleWidth;
    output.reserve(dummyCount + outputSize);
    bool *tuple;


    for(int i = 0; i < dummyCount; ++i){
    output += to_string(results->dummyTags[i].reveal(XOR));
    }

    for(int i = 0; i < results->publicSize; ++i) {
         tuple = outputBits(results->data[i], tupleWidth, XOR);
         for(int j = 0; j < tupleWidth; ++j) {
                 output += (tuple[j] ? '1' : '0');
             }
    }

// debug final output
// cout << " Final output from EMP is: " << output << endl;

io->flush();
delete io;

cout << "Finished query!" << endl;

}








int main(int argc, char** argv) { 
	int party, port;
	parse_party_and_port(argv, 2, &party, &port);
	run(party, port);
	return 0;
}
}; // end class
} // end namespace
 
