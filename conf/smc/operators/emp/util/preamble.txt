#include <emp-sh2pc/emp-sh2pc.h>
#include <pqxx/pqxx>
#include "row.h"

// header of an ExecutionSegment in emp
// put in front of first generated MPC operator


using namespace emp;
using namespace std;
using namespace pqxx;




namespace $queryName {

class $queryClass {
// Connection strings, encapsulates db name, db user, port, host
string aliceConnectionString = "$aliceConnectionString";
string bobConnectionString = "$bobConnectionString";
string bobHost = "$bobHost";
bool *output;
int LENGTH_INT = 64;



// Helper functions
string reveal_bin(Integer &input, int length, int output_party) {
    bool * b = new bool[length];
    ProtocolExecution::prot_exec->reveal(b, output_party, (block *)input.bits,  length);
    string bin="";
    
    for (int i=0; i<length; i++)
        bin += (b[i] ? '1':'0');
    
    delete [] b;
    return bin;
}

	bool * outputBits(Integer &input, int length, int output_party) {
		bool * b = new bool[length];
		ProtocolExecution::prot_exec->reveal(b, output_party, (block *)input.bits,  length);
		string bin="";

		return b;
	}


void cmp_swap_sql(Integer*key, int i, int j, Bit acc, int key_pos, int key_length) {
    Integer keyi = Integer(key_length, key[i].bits+key_pos);
    Integer keyj = Integer(key_length, key[j].bits+key_pos);
    Bit to_swap = ((keyi > keyj) == acc);
    swap(to_swap, key[i], key[j]);
}

// TODO: extend this to multiple columns as a list of key_pos and key_length
void bitonic_merge_sql(Integer* key, int lo, int n, Bit acc, int key_pos, int key_length) {
    if (n > 1) {
        int m = greatestPowerOfTwoLessThan(n);
        for (int i = lo; i < lo + n - m; i++)
            cmp_swap_sql(key, i, i + m, acc, key_pos, key_length);
        bitonic_merge_sql(key, lo, m, acc, key_pos, key_length);
        bitonic_merge_sql(key, lo + m, n - m, acc, key_pos, key_length);
    }
}

void bitonic_sort_sql(Integer * key, int lo, int n, Bit acc,  int key_pos, int key_length) {
    if (n > 1) {
        int m = n / 2;
        bitonic_sort_sql(key, lo, m, !acc, key_pos, key_length);
        bitonic_sort_sql(key, lo + m, n - m, acc, key_pos, key_length);
        bitonic_merge_sql(key, lo, n, acc, key_pos, key_length);
    }
}

bool *concat(std::vector<Row> rows, int row_size) {
    bool *result = new bool[row_size*rows.size()];
    int num_rows = rows.size();

    for (int i=0; i<num_rows; i++) {
        memcpy(result + i*row_size, rows[i].to_bool(), row_size);   
    }
    return result;
}

int sum_vals(vector<int> vec) {
    int sum = 0;
    for (int i : vec)
        sum += i;
    return sum;
}

// DB connection functions
std::vector<Row> execute_sql(string sql, int party) {
    std::vector<Row> res;
    try {
        string config= (party == ALICE) ? aliceConnectionString : bobConnectionString;
        connection C(config);

        if (C.is_open()) {
            cout << "Opened database successfully: " << C.dbname() << endl;
            work w(C);
            result r = w.exec(sql);
            w.commit();

            for (auto row : r) {
            	const int num_cols = row.size();
            	vector<int>lengths;
            	string bin_str = "";
            	for (int j=0; j<num_cols; j++) {
            	    int val;
                    string str;
                    try {
                        row[j].to(val);
                        lengths.push_back(LENGTH_INT);
                        bin_str += int64_to_binstr(val);
                    } catch (const std::exception& ex) {
                        try {
                            row[j].to(str);
                            lengths.push_back(str.length());
                            bin_str += str_to_binary(str, str.length());
                        } catch (const std::exception& ex) {
                            throw runtime_error("Unsupported data type in column");
                        }
                    }
            	}
            	res.push_back(Row(bin_str, lengths));
            }
        } else {
            cout << "Can't open database" << endl;
        }
        C.disconnect();
    } catch (const std::exception &e) {
        cerr << e.what() << std::endl;
    }

    return res;
}

// Operator functions
class Data {
public:
    Integer * data;
    int public_size;
    Integer real_size;
    Integer dummyTags;
};

Integer from_bool(bool* b, int size, int party) {
    Integer res;
    res.bits = new Bit[size];
    init(res.bits, b, size, party);
    return res;
}



