// TODO: generalize for arbitrary selection criteria
// see ObliVM generator for example of this
// this example is based on aspirin expected code
Data * $functionName(Data *left, Data *right) {
    Integer *output = new Integer[left->public_size * right->public_size];
    int writeIdx = 0;
    Integer dstTuple, srcTuple, lTuple, rTuple;
    int jointSchemaSize = $lSize + $rSize;
    srcTuple = Integer();
    srcTuple.resize(jointSchemaSize);
    
    dstTuple = Integer($dSize, 0, PUBLIC); // indicates dummy
    
    for (int i=0; i<left->public_size; i++) {
        for (int j=0; j<right->public_size; j++) {
        	lTuple = left->data[i];
        	rTuple = right->data[j];
        	// concatenate the two inputs into srcTuple, the standard join output schema
        	memcpy(srcTuple.bits, lTuple.bits, $lSize);
        	memcpy(srcTuple.bits + $lSize, rTuple.bits, $rSize);
        	
        	Bit cmp = $filterCond;
        	$writeDst;
        	dstTuple = If(cmp, dstTuple, Integer($dSize, 0, PUBLIC)); 
	        output[writeIdx] = dstTuple;
            writeIdx++;
            
        }
    }
    Data *result = new Data;
    result->data = output;
    // output tuple count
    result->public_size = left->public_size * right->public_size;
	// real size needs to be maintained by counting the times the join criteria is met
	// this variable should probably not be public
    result->real_size = Integer(64, left->public_size, PUBLIC);
    return result;
}
