// TODO: generalize for arbitrary selection criteria
// see ObliVM generator for example of this
// this example is based on aspirin expected code
Data * $functionName(Data *left, Data *right) {
 
    int writeIdx = 0;
    Integer dstTuple, srcTuple, lTuple, rTuple;
    int jointSchemaSize = $lSize + $rSize;
    int outputTupleCount = left->publicSize * right->publicSize;

	Data *result = new Data;
    
	srcTuple = Integer(jointSchemaSize, 0, PUBLIC);
    

    // output tuple count
    result->data = new Integer[outputTupleCount];
    result->publicSize = outputTupleCount;
    result->dummyTag = new Bit[outputTupleCount];
    
    dstTuple = Integer($dSize, 0, PUBLIC);
	
    for (int i=0; i < left->publicSize; i++) {
        for (int j=0; j < right->publicSize; j++) {
        	lTuple = left->data[i];
        	rTuple = right->data[j];
	        	
        	// concatenate the two inputs into srcTuple, the standard join output schema
        	memcpy(srcTuple.bits, lTuple.bits, $lSize);
        	memcpy(srcTuple.bits + $lSize, rTuple.bits, $rSize);
        	
        	// TODO: rewire filter flattener to skip the memcopies above
        	Bit cmp = $filterCond;
        	
        	// populate dstTuple with any projections
        	$writeDst;
	       
	       // if selection criteria true and neither input is a dummy
	        result->dummyTag[writeIdx] = If(cmp & !left->dummyTag[i] & !right->dummyTag[j], Bit(0, PUBLIC), Bit(1, PUBLIC));        	
        	
	        result->data[writeIdx] = dstTuple;
            writeIdx++;
            
        }
    }
    return result;
}
