// ordered union, multiset op, has multiset semantics
// inputs must be sorted by sort key from query plan in source DBs
// right now this presumes that the sort key is always the first column.
// need to make this more general by tweaking the parameters 


Data* op_ordered_merge(string sql, vector<int> input_col_lengths, int party, NetIO * io) {
    std::vector<Row> in = execute_sql(sql, party);
    // TODO: sort in rows
    int bit_length = sum_vals(input_col_lengths);
    // flatten out local data
    bool *local_data = concat(in, bit_length);

    int alice_size = in.size();
    int bob_size = in.size();
    if (party == ALICE) {
        io->send_data(&alice_size, 4);
        io->flush();
        io->recv_data(&bob_size, 4);
        io->flush();
    } else if (party == BOB) {
        io->recv_data(&alice_size, 4);
        io->flush();
        io->send_data(&bob_size, 4);
        io->flush();
    }

    Integer * res = new Integer[alice_size + bob_size];
    Bit * tmp = new Bit[bit_length * (alice_size + bob_size)];
    for (int i = 0; i < alice_size; ++i)
        for (int j = 0; j < bit_length; ++j)
            tmp[i*bit_length + j] = Bit((ALICE==party) ? 
                local_data[(alice_size-i-1)*bit_length + j]:0, ALICE);

    Batcher batcher;
    for (int i = 0; i < bob_size*bit_length; ++i)
        batcher.add<Bit>((BOB==party) ? local_data[i]:0);
    batcher.make_semi_honest(BOB);

    for (int i = 0; i < bob_size*bit_length; ++i)
        tmp[i+alice_size*bit_length] = batcher.next<Bit>();

    for(int i = 0; i < alice_size + bob_size; ++i)
        res[i] = Integer(bit_length, tmp+bit_length*i);


    bitonic_merge_sql(res, 0, alice_size + bob_size, Bit(true), 0, col_length0);
    Data * d = new Data;
    d->data = res;
    d->public_size = alice_size + bob_size;
    d->real_size = Integer(64, d->public_size, PUBLIC);
        
    return d;
}