Data* $functionName(int party, NetIO * io) {

    // std::cout << "Testing that this is the correct template" << std::endl;

    int rowLength = $size;

    std::cout << "The rowlength in bits is " << rowLength << std::endl;

    // rowLength = 64; // manual reset. if not reset, then suspects fewer tuples


	string localBitstring = inputs["$functionName"];
	string localDummyTags = dummyTagsMap["$functionName"];

	std::cout << " Dummies " << localDummyTags << std::endl;
	std::cout << " rowLength " << rowLength << std::endl;

    bool *localData = toBool(localBitstring);
    bool *localDummies = toBool(localDummyTags);


    int aliceSize = localBitstring.length() / rowLength;
    int bobSize = aliceSize;

    if (party == ALICE) {
        io->send_data(&aliceSize, 4);
        io->flush();
        io->recv_data(&bobSize, 4);
        io->flush();
    } else if (party == BOB) {
        io->recv_data(&aliceSize, 4);
        io->flush();
        io->send_data(&bobSize, 4);
        io->flush();
    }

    Integer * res = new Integer[aliceSize + bobSize];  // enough space for all inputs
    Bit * dummyTags = new Bit[aliceSize + bobSize]; // same for dummies
   
    Bit * tmp = new Bit[rowLength * (aliceSize + bobSize)]; //  bit array of inputs
    bool *readPos = localData;
    Bit *dummyPtr = dummyTags;

    int writePos = 0;
    int writeTuple = aliceSize; // last tuple
    
    for (int i = 0;  i < aliceSize; ++i) {
    	--writeTuple;
    	writePos = writeTuple * rowLength;
        for (int j = 0; j < rowLength; ++j) {
            tmp[writeTuple*rowLength + j] = Bit((ALICE==party) ? 
                *readPos:0, ALICE);
            ++readPos;
            ++writePos;
         }
	}
	
    Batcher batcher;

    /*

    I think this is where we should add dummyTag info, but unsure
    for(int i = 0; i < alice_size; ++i) {
           batcher.add<Bit>((ALICE==party) ? dummyTags[i]:0);
    }

    */

    for (int i = 0; i < bobSize*rowLength; ++i)
       // set up bit array, if alice, secret share a local bit,
       // otherwise bob collects his part of the secret share and inputs 0 as a placeholder
        batcher.add<Bit>((BOB==party) ? localData[i]:0);

    batcher.make_semi_honest(BOB);

    for (int i = 0; i < bobSize*rowLength; ++i)
        tmp[i+aliceSize*rowLength] = batcher.next<Bit>();

    for(int i = 0; i < aliceSize + bobSize; ++i)
        res[i] = Integer(rowLength, tmp+rowLength*i);

    cout << "$functionName took as input " << aliceSize + bobSize << " tuples from alice and bob." << endl;

	/*for(int i = 0; i < (aliceSize + bobSize); ++i) {
    	long value = res[i].reveal<int64_t>(PUBLIC);
    	cout << "Value i: " << value << endl;
    }*/
    
    // TODO: make sort more robust.  Handle sort keys that are not adjacent or in the same order in the table
    bitonic_merge_sql(res, 0, aliceSize + bobSize, Bit(true), $keyPos, $keyLength);
    

    Data * d = new Data;
    d->data = res;
    // data->dummyTag = dummyTag; // Added
    d->publicSize = aliceSize + bobSize;
    d->realSize = Integer(64, d->publicSize, PUBLIC);
    cout << "Done union!" << endl;   
    return d;
}
