// ordered union, multiset op, has multiset semantics
// inputs must be sorted by sort key from query plan in source DBs
// right now this presumes that the sort key is always the first column.
// need to make this more general by tweaking the parameters 


void OTData(bool* localData, Bit* dst, long size, int sendingParty, int myParty) {
	Batcher batcher;
	cout << "Running batcher!" << endl;
	for(int i = 0; i < size; ++i) {
		batcher.add<Bit>((sendingParty == myParty) ? localData[i]:0);
	}
	
	batcher.make_semi_honest(sendingParty);
	
	for (int i = 0; i < size; ++i) {
        *dst = batcher.next<Bit>();
        ++dst;
	}
     
}

Data* $functionName(int party, NetIO * io) {
    cout << "Running $functionName!" << endl;

	string sql = "$sql";
    std::vector<Row> in = execute_sql(sql, party);
    cout << "Received query results" << endl;

    int bit_length = $size; 
    // flatten out local data
    bool *local_data = concat(in, bit_length);

    int alice_size, bob_size;
    alice_size = bob_size = in.size();
	cout << "setting up OT!" << endl;

    if (party == ALICE) {
        io->send_data(&alice_size, 4);
        io->flush();
        io->recv_data(&bob_size, 4);
        io->flush();
    } else if (party == BOB) {
        io->recv_data(&alice_size, 4);
        io->flush();
        io->send_data(&bob_size, 4);
        io->flush();
    }

	Integer * res = new Integer[alice_size + bob_size];  // enough space for all inputs
    Bit * tmp = new Bit[bit_length * (alice_size + bob_size)]; //  bit array of inputs
    Bit *tmpPtr = tmp;
   
    cout << "Sending bob!" << endl;
    
    OTData(local_data, tmpPtr, bob_size * bit_length, party, BOB);
    io->sync();
    
    
    tmpPtr +=  bob_size * bit_length;
       
    cout << "Sending Alice" << endl;    
    OTData(local_data, tmpPtr, alice_size * bit_length, party, ALICE);
    
	tmpPtr = tmp;
	
	cout << "Making tuples!" << endl;
	// create a 2D array of secret-shared bits
	// each index is a tuple
    for(int i = 0; i < alice_size + bob_size; ++i) {
        res[i] = Integer(bit_length, tmpPtr);
        tmpPtr += bit_length;
     }


	cout << "Done OT!" << endl;
    // TODO: make sort more robust s.t. the sort columns need not be adjacent
    bitonic_merge_sql(res, 0, alice_size + bob_size, Bit(false), $keyPos, $keyLength);
    Data * d = new Data;
    d->data = res;
    d->public_size = alice_size + bob_size;
    d->real_size = Integer(64, d->public_size, PUBLIC);
      
    cout << "Done union!" << endl;   
       
    return d;
}
