Data* $functionName(int party, NetIO * io) {
    cout << "Running $functionName!" << endl;
    string sql = "$sql";
    std::vector<Row> in = execute_sql(sql, party);
    
    cout << "Received query results" << endl;
    int rowLength = $size; 
    bool *localData = concat(in, rowLength);


    int aliceSize = in.size();
    int bobSize = in.size();


    if (party == ALICE) {
        io->send_data(&aliceSize, 4);
        io->flush();
        io->recv_data(&bobSize, 4);
        io->flush();
    } else if (party == BOB) {
        io->recv_data(&aliceSize, 4);
        io->flush();
        io->send_data(&bobSize, 4);
        io->flush();
    }

    Integer * res = new Integer[aliceSize + bobSize];  // enough space for all inputs
   
    Bit * tmp = new Bit[rowLength * (aliceSize + bobSize)]; //  bit array of inputs
    Bit *tmpPtr = tmp;

    Batcher aliceBatcher, bobBatcher;
   
    int bobBits = bobSize * rowLength;
    int aliceBits = aliceSize * rowLength;

    for (int i = 0; i < bobBits; ++i) {
    	bobBatcher.add<Bit>((BOB==party) ? localData[i]:0);
     }
     
    bobBatcher.make_semi_honest(BOB);



    // append all of bob's bits to tmp
    for (int i = 0; i < bobBits; ++i) {
        *tmpPtr = bobBatcher.next<Bit>();
        ++tmpPtr;
	}
   

    for (int i = 0; i < aliceBits; ++i) {
    	aliceBatcher.add<Bit>((ALICE==party) ? localData[i]:0);
    }

    aliceBatcher.make_semi_honest(ALICE);


    for(int i = 0; i < aliceBits; ++i) {
    	    *tmpPtr = aliceBatcher.next<Bit>();
	    	    ++tmpPtr;
		    }

   		    // resetting cursor
		    tmpPtr = tmp;
		    
		    // create a 2D array of secret-shared bits
		    // each index is a tuple
    for(int i = 0; i < aliceSize + bobSize; ++i) {
        res[i] = Integer(rowLength, tmpPtr);
        tmpPtr += rowLength;
     }


    Data * d = new Data;
    d->data = res;
    d->publicSize = aliceSize + bobSize;
    d->realSize = Integer(64, d->publicSize, PUBLIC);
    cout << "Done union!" << endl;   
    return d;
}
