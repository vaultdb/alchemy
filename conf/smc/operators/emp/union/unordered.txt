Data* $functionName(int party, NetIO * io) {
    string sql = "$sql";
    std::vector<Row> in = execute_sql(sql, party);
    int bit_length = $size; // TODO: automatically derive size from Row metadata?
    bool *local_data = concat(in, bit_length);

    int alice_size = in.size();
    int bob_size = in.size();
    Batcher alice_batcher, bob_batcher;
    
    // line up input sizes
    if (party == ALICE) {
        io->send_data(&alice_size, 4);
        io->flush();
        io->recv_data(&bob_size, 4);
        io->flush();
    } else if (party == BOB) {
        io->recv_data(&alice_size, 4);
        io->flush();
        io->send_data(&bob_size, 4);
        io->flush();
    }

    Integer * res = new Integer[alice_size + bob_size];  // enough space for all inputs
    
    Bit * tmp = new Bit[bit_length * (alice_size + bob_size)]; //  bit array of inputs
    Bit *tmpPtr = tmp;
    
    for (int i = 0; i < alice_size*bit_length; ++i) {
        	   // set up bit array, if alice, secret share a local bit, 
        	   // otherwise bob collects his part of the secret share and inputs 0 as a placeholder
        	   alice_batcher.add<Bit>((ALICE==party) ? local_data[i]:0);
    }
     
	alice_batcher.make_semi_honest(ALICE);
		
	for(int i = 0; i < alice.size*bit_length; ++i) {
		*tmpPtr = batcher.next<Bit>();
		++tmpPtr;
	}
	
    for (int i = 0; i < bob_size*bit_length; ++i)
        bob_batcher.add<Bit>((BOB==party) ? local_data[i]:0);
    bob_batcher.make_semi_honest(BOB);

	// append all of bob's bits to tmp
    for (int i = 0; i < bob_size*bit_length; ++i) {
        *tmpPtr = batcher.next<Bit>();
        ++tmpPtr;
	}
	
	tmpPtr = tmp;
	// create a 2D array of secret-shared bits
	// each index is a tuple
    for(int i = 0; i < alice_size + bob_size; ++i) {
        res[i] = Integer(bit_length, tmpPtr);
        tmpPtr += bitLength;
     }


    Data * d = new Data;
    d->data = res;
    d->public_size = alice_size + bob_size;
    d->real_size = Integer(INT_SIZE, d->public_size, PUBLIC);
        
    return d;
}